A description of the implementation of the heuristic was mentioned at the beginning of this chapter. This section will go further into detail about
the actual implementation in Python. In the following a distinction will be made concerning the steps of the programs for the probabilistic version
in which a starting solution is generated randomly and the deterministic version, where a new solution is generated by moving the starting times
of vehicles not starting at 0 by a set amount.

Both variations have the same base structure: After a maximum amount of vehicles is given, the algorithm starts by setting the number of available
vehicles to 1. The sequence for the first iteration is completely deterministic as all opening sequences set the starting point of the first available
vehicle to 0. This is introduced to increase the chances of receiving a "best solution" in which at least one vehicle starts at 0. The reason for this is
that the regularity of the objective function guarantees that each sequence not containing a vehicle starting at 0 is non-optimal.
This sequence is then fed into the simulation program to return the first objective value and base value for the comparison of future values found in the heuristic. This solution with its corresponding objective
value is also separately stored as the current best found solution in the iteration and overall. The next step is the start of the local search:
For each vehicle in the schedule two new schedules are generated. In the first the observed vehicle is set to start one unit of time earlier. In
the second schedule it is set to start one unit later. As described above, when the amount of vehicles is set to 1 the newly generated solutions
will not provide improvements. For consistency reasons these calculations have not been excluded as they are irrelevant solely in the "one vehicle"-case.
For cases with more than one vehicle, a change from a schedule with one vehicle starting at 0 to a schedule with none doing so may be an improvement.
The reason for this is that while it can be stated that a schedule with no vehicle starting at 0 is definitely not optimal, it can still return a better
objective value than a schedule with at least one vehicle starting at 0. In later iterations, in which the amount of vehicles is set to be greater than
one, the neighbourhood search returns two times the amount of vehicles schedules. As the local search does not include a tabu list, every time the
local search is applied beyond the first time, it will return the previously best found schedule among others. As the rule for choosing the next best
found schedule requires a schedule to have a strictly better objective value, this does not pose a problem.

Each time a new schedule is generated from the neighbourhood it is run through the simulation. If the objective value of the schedule is better
(lower) than the best schedule found until now in the current iteration it is replaced. Following schedules from the same neighbourhood will already
be compared to the new best schedule. New schedules are obtained in the following chronological order: A new schedule is generated for each vehicle
starting one unit of time earlier, then new schedules are generated for each vehicle starting one unit later. If there are multiple schedules in
the neighbourhood that return the same objective value, the first one obtained in the order of generation is kept and the others are discarded.

One iteration of the heuristic runs until an instance of the neighbourhood search does not return a better objective value for any of the regarded
schedules. After each iteration the best found solution is compared to the overall best solution with the same amount of vehicles found so far.
If it is better then the schedule and the corresponding objective value are stored. For each all integer amounts of vehicles up to the set maximum
this process is repeated a number of times equal to the amount of iterations set as a parameter upon the start of the program. Each of the iterations
will start with a new starting sequence. Here is where the differences of the probabilistic and the deterministic approach come into play. The probabilistic
approach simply sets the starting point of the first vehicle to one and randomizes the starting points of all the other vehicles. The deterministic
approach on the other hand needs an additional parameter which sets the length of the "jump" that all starting times other than those of vehicles
starting at 0 make. The idea behind a deterministic approach is to try and find a distance of the "jump" which helps to cover most of the population.
Setting the length of the jump too low will result in getting stuck in a local optimum, while setting it too high will have similar results to simply
generating the starting sequences at random. To show the influence of the jump lengths on the solution quality of the heuristic, different jump lengths
are tested and put into comparison in the following chapter.

Before finally being able to print the found solutions two more steps are implemented: 

\begin{itemize}
  \item If the best solution found for any amount of vehicles returns a worse objective value than the solution with one less vehicles, a new sequence
    is generated. The starting time of all vehicles of the lower solutions are copied and the last remaining vehicle receives a random starting time.
    This objective value of the newly generated solution is at least as good as the objective value of the sequence without the last vehicle.
  \item If either of the best solutions is a sequence that does not contain any vehicle starting at 0, all of the vehicles contained in the sequence
    are set to start exactly as many units of time earlier as it takes until at least one vehicle starts at 0. The regularity of the target function
    guarantees that the objective value of the newly generated sequence will be exactly that many units of times lower.
\end{itemize}

The program of the heuristic finishes by "fusing" the starting times of the vehicles for compared amounts of vehicles into a single array and prints
the received array alongside the corresponding objective value. These values may then be displayed graphically to form a pareto front.