The local search algorithms described in the previous chapters have been implemented in Python and run against a test case that has been solved to optimality with a brute-force algorithm. The test case contains the following set-up:
\begin{itemize}
\item 25 jobs
\item 10 machine stages
\item up to 8 AGVs
\item constant transportation time of 2 between two successive machines
\end{itemize}
The amount of parallel machines at each of the production stage is set to two with the exception of stage 7, which hosts three parallel machines. The schedule determining the order in which all jobs have to be processed at the machine stages is set to be a flow shop schedule not changing throughout the enterity of the system. All of the jobs are aligned in a way that job number one equals the job to be processed first at all of the machine stages. Not that in this model the schedule only predetermines the starting order of jobs at machine stages, it does not entail that job number two has to wait until job number one has finished processing, but rather may be started at another parallel machine as soon as job one has been started. The processing time of each job at each machine stage has been randomly determined to be an integer between one to ten and has been stored in a text file to be read by the python implementation upon each start of the program.

As stated previously the test case was solved to optimality with a brute-force algorithm for all integer amounts of AGVs up to a maximum of eight. The brute-force algorithm however did not compute every single possible combination of starting times of the AGVs but used two properties of the problem to reduce the amount of combinations needed. The first of these is the objective function being looked at: The minimization of the maximum makespan of all jobs is proven to be regular. Therefore for any amount of AGVs at least one has to start at "0" as any delay in starting the first AGV automatically results in a delay of the overall program of the same amount. This automatically returns the optimal solution for the case in which only a single AGV is available. All starting points of AGVs past the first one are still able to be selected freely. The second reduction of combinations to be calculated uses the idea that there is no difference between the AGVs. A schedule of the first AGV starts after zero units of time and the second starts after two will yield the same solution as if the first would start after two units of time and the second would start after zero. This property allows for the following: The brute-force algorithm predetermines a chronological order in which he assigns the AGV to a new starting time. Every AGV may only start at the same starting time or later than its direct predecessor. To better explain this concept consider the following with three total AGVs to be assigned to starting times: The first AGV starts after zero units of time due to the regularity of the objective function. The second AGV may now start at zero units of time or at any later point. In the first iteration the brute-force algorithm will always choose the lowest starting time in which not all possibilities for the schedules of sucessing AGVs are exhausted. The third AGV will start after zero units of time in the first iteration and then increase its starting time by one in each of the following. After all combinations for the third AGV have been exhausted, the starting time of the second AGV is moved back by one unit of time. If however the third AGV was to start after zero units of time again, then it would result in the same solution as the overall second iteration in which the second AGV started at "0" and the third AGV at "1". Therefore the third AGV will only start at the same or a later time than the second and this method is replicated for any number of AGVs in the algorithm.

The following table displays the correct solutions and the run time of the brute-force algorithm in seconds. Note that even for this relatively small test case the run time to find the optimal solution for an amount of eight AGVs almost reaches three hours.

TABLE OPT SOL

The implemented heuristical approaches are all compared to an implementation that has been chosen to be the base of comparison for all other implementations. All of the approaches differ either in amount of iterations of the neighborhood search or the pertubation step when "jumping" from a found local optimum. The basic approach is set to have fourty iterations and uses a pertubation that simply generates a new random solution and applies the local search algorithm from there. All the different variations of the heuristic have been run 20 times and the received solutions are compared to the optimal solution in the following parameters:
\begin{itemize}
\item average returned solution and percentage deviation from optimum
\item amount of times the optimal solution has been found
\item average run time
\end{itemize}
These criteria will be compared among all the implemented variations of the heuristic and for all amounts of AGVs between one and eight.

The comparisons between the different variations of the heuristic are divided into two groups: One group compares the differences if the amount of iterations is changed and the second compares a changes in pertubation, switching from a random jump to a predetermined strength.

For the first comparison a total of three different amounts of iterations are regarded: the basic version with 40 iterations, a faster version with half the iterations at 20 and a slower version with an additional 20 iterations coming to a total of 60. The following table shows the differences of the three versions in the parameters listed above. Below the table there is a graphic visualization of the average achieved solution value compared to the optimal solution for AGV amounts between five to eight.

TABLE COMP IT

GRAPH COMP IT

As the table clearly shows, the amount of iterations is almost perfectly directly proportional to the time needed for the calculation, with small deviations occuring due to the initial reading of the input only occuring once no matter the amount of deviations and due to the amount of searches in one iteration of a neighborhood search being random. The time displayed is the average time it took for the heuristic to compute solutions for all different amounts of AGVs up to eight. All versions of the heuristic stay far below the time needed for the optimal solution while still maintaining a relatively decent average deviation. Something that can already be seen with a small number of calculations like 20 is that even though the version with the least iterations hit the optimal solution for seven AGVs the most times, the average deviation from the optimal solution is continuously decreasing with the amount of iterations calculated throughout all different amounts of AGVs. Overall it can be said that the results of the comparison with variable iterations are not differing from what was to be expected.

The second comparison serves to reveal differences in the quality of solutions achieved through changing the pertubation from randomly selecting a new point to "jumping" a predetermined distance to escape the local optimum. For this calculation three different pertubation strengths have been chosen for comparison: three, five and ten. The amount of iterations stays the same throughout all of the variations. The following table and graph display the attained solutions.

TABLE COMP PERT

GRAPH COMP PERT

