#!/usr/bin/env python3
"""
This module includes an iterative local search algorithm for the cyclic flexible
flow shop problem with a two-dimensional target function including the makespan
and the amount of vehicles.
"""
from readschedule import read_schedule,read_input

def heuristic(maxvehicles,production_machines,pmachinesperstage,jobs,roundtime,timebetweenmachines,schedule,duration,iterations):
    """
    This function implements an iterative local search algorithm for a given
    amount of iterations and maximum amount of vehicles

    The local search algorithm searches the neighborhood of a randomly generated
    starting solution for possible improvements. The best found becomes the new
    currently saved solution and the neighborhood search begins anew. An iteration
    breaks if no better solution can be found and the current solution is saved
    as the saved as the best overall solution if it surpasses the currently saved
    best solution. This process is iterated over a given amount of times and for
    each integer amount of vehicles up to the predefined maximum. The function
    then returns the best solution found for all distinct numbers of vehicles.
    The return can be graphically displayed as a pareto-front and subjected to
    a second target function, e.g. a cost function, to determine the situational
    best solution out of the received.
    """
    from readschedule import read_schedule
    import numpy as np
    from random import randint
    import math

    best_solutions = np.ones(maxvehicles)*math.inf
    best_schedule = []
    for i in range(maxvehicles):
        best_schedule.append(0)
    for vehicles in range(1,maxvehicles+1):
        """
        generating a random opening sequence and a new sequence for in each
        iteration

        The opening sequence is generated by taking a list of zeros the length
        of possible starting points and replacing a random one with a one for each
        of the vehicles in the given iteration. Exception: the first machine is
        set to start at 0 to increase the chance of finding a solution in which
        at least one machine starts at 0.
        """
        for iteration in range(iterations):
            opening_sequence = np.zeros((vehicles, roundtime))
            opening_sequence[0,0] = 1
            for i in range(1,vehicles):
                opening_sequence[i, randint(0,roundtime-1)] = 1
            opening_solution = read_schedule(vehicles,production_machines,pmachinesperstage,jobs,opening_sequence,roundtime,timebetweenmachines,schedule,duration)
            best_solution = opening_solution
            best_sequence = opening_sequence
            current_solution = opening_solution
            current_sequence = opening_sequence
            """
            generating neighborhood solutions

            neighborhood solutions are generated by allowing every machine to
            start either one unit of time earlier or later, but only one machine
            may change at a time. This leads to 2*vehicles as the size of the
            neighborhood in each iteration
            """
            nobettersolution = 0
            while nobettersolution == 0:
                startlist=np.zeros(vehicles, dtype=int)
                for i in range(vehicles):
                    # find start of act machine i:
                    for j in range(roundtime):
                        startlist[i]+= current_sequence[i,j]*j


                for i in range(vehicles):
                    # move the 1 to the left
                    new_sequence = current_sequence.copy()
                    new_solution = 0
                    for j in range(0, roundtime):
                        if new_sequence[i,j] == 1:
                            new_sequence[i,j] = 0
                            new_sequence[i,(j-1)%roundtime] = 1
                            break
                    new_solution = read_schedule(vehicles,production_machines,pmachinesperstage,jobs,new_sequence,roundtime,timebetweenmachines,schedule,duration)
                    if new_solution < best_solution:
                        best_solution = new_solution
                        best_sequence = new_sequence.copy()

                for i in range(vehicles):
                    new_sequence = current_sequence.copy()
                    new_solution = 0
                    for j in range(0, roundtime):
                        if new_sequence[i,j] == 1:
                            new_sequence[i,j] = 0
                            new_sequence[i,(j+1)%roundtime] = 1
                            break
                    new_solution = read_schedule(vehicles,production_machines,pmachinesperstage,jobs,new_sequence,roundtime,timebetweenmachines,schedule,duration)
                    if new_solution < best_solution:
                        best_solution = new_solution
                        best_sequence = new_sequence
                """
                Accepting better solutions and breaking an iteration

                the heuristic runs until it cannot find a solution that returns
                a lower goal than the one returned in the previous iteration.
                if a better solution is found then the heuristic will generate a
                new neighborhood starting from the newly found solution
                """
                if best_solution == current_solution:
                    nobettersolution = 1
                else:
                    current_solution = best_solution
                    current_sequence = best_sequence

            if best_solution < best_solutions[vehicles-1]:
                best_solutions[vehicles-1] = best_solution
                best_schedule[vehicles-1] = best_sequence.copy()
        """
        Optimizing of returned solutions by using the regularity of the target
        function(Cmax)

        As a final step before the return of the received solutions every schedule
        is moved to make sure that the first machine does indeed start at time 0
        ([0,1,0,1] gets a strictly worse solution than [1,0,1,0], regularity
        states that the second schedule will save the unnecesserily waited unit
        of time of the first schedule, and will therefore return a better solution
        """
        if vehicles > 2:
            if best_solutions[vehicles-1] > best_solutions[vehicles-2]:
                new_sequence = np.zeros((vehicles, roundtime))
                for i in range(vehicles-1):
                    for j in range(roundtime):
                        new_sequence[i,j] = best_schedule[vehicles-2][i,j]
                new_sequence[vehicles-1, randint(0,roundtime-1)] = 1
                new_solution = read_schedule(vehicles,production_machines,pmachinesperstage,jobs,new_sequence,roundtime,timebetweenmachines,schedule,duration)
                print(new_solution, vehicles)
                print(new_sequence)
                if new_solution < best_solution:
                    best_solutions[vehicles-1] = new_solution
                    best_schedule[vehicles-1] = new_sequence.copy()

    return [best_solutions,best_schedule]



if __name__ == "__main__":
    #heuristic(maxvehicles,production_machines,pmachinesperstage,jobs,roundtime,timebetweenmachines,schedule,duration,iterations)
    duration = [read_input("ptime.txt")][0]
    schedule = [read_input("pschedule.txt")][0]
    pmachinesperstage = [read_input("pmachinesperstage.txt")][0]
    printnow=heuristic(8,10,pmachinesperstage,25,22,2,schedule,duration,40)
    schedules = []
    startsum = 0
    for i in range(len(printnow[1])):
        for k in range(len(printnow[1][0][0])):
            for j in range(len(printnow[1][i])):
                startsum += printnow[1][i][j][k]
            schedules.append(int(startsum))
            startsum = 0
        while schedules[0] < 1:
            for j in range(len(schedules)):
                if schedules[j] >= 1:
                    schedules[j-1] = schedules[j]
                    schedules[j] = 0
            printnow[0][i] -= 1
        print("Solution with {} vehicles: {}".format(i+1,printnow[0][i]))
        print("Schedule:")
        print(schedules)
        schedules =[]
